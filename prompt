Prompt para Cursor:
# OMOMoney - SwiftUI Expense Tracker App Development

## üö® REGLAS ESTRICTAS DE DESARROLLO - OBLIGATORIAS

### üì± VERSI√ìN DE PLATAFORMA - OBLIGATORIO
- **iOS Target**: iOS 18.5+ (2025)
- **SwiftUI**: Usar APIs m√°s modernas disponibles
- **Compatibilidad**: No usar APIs deprecadas

### üèóÔ∏è ARQUITECTURA MVVM - NO NEGOCIABLE
- **Views**: ‚ùå NO contienen l√≥gica, ‚ùå NO c√°lculos, ‚ùå NO formateo, ‚úÖ SOLO SwiftUI Views
- **ViewModels**: ‚ùå NO contienen UI, ‚úÖ SOLO l√≥gica de presentaci√≥n, ‚úÖ @MainActor, ‚úÖ @Published
- **Services**: ‚úÖ SOLO l√≥gica CRUD y operaciones de datos, ‚úÖ NO l√≥gica de presentaci√≥n
- **Models**: ‚ùå NO contienen l√≥gica, ‚úÖ SOLO entidades Core Data
- **Core Data Integration**: ‚úÖ SIEMPRE usar NSFetchedResultsController para respetar MVVM

### üßµ THREADING - CR√çTICO
- **Main Thread**: ‚úÖ SOLO UI, ‚úÖ navegaci√≥n, ‚úÖ gestos, ‚úÖ animaciones
- **Background Thread**: ‚úÖ Core Data CRUD, ‚úÖ c√°lculos complejos, ‚úÖ filtros pesados
- **Patr√≥n obligatorio**: `DispatchQueue.global` ‚Üí operaci√≥n pesada ‚Üí `DispatchQueue.main.async`

### üóÑÔ∏è CORE DATA + MVVM - OBLIGATORIO
- **NSFetchedResultsController**: ‚úÖ SIEMPRE usar para respetar MVVM y arquitectura limpia
- **Beneficios**:
  - ‚úÖ **Reactividad autom√°tica**: Se actualiza solo cuando Core Data cambia
  - ‚úÖ **Performance**: Solo carga datos cuando es necesario
  - ‚úÖ **MVVM puro**: ViewModel no maneja l√≥gica de Core Data
  - ‚úÖ **Nativo**: Usa las APIs oficiales de Apple
  - ‚úÖ **Eficiente**: No polling, no notificaciones manuales
- **Implementaci√≥n**:
  - ViewModel implementa `NSFetchedResultsControllerDelegate`
  - `@Published var entries` se actualiza autom√°ticamente
  - SwiftUI re-renderiza cuando `@Published` cambia
  - **NO usar NotificationCenter** para cambios de Core Data

### üì± SWIFTUI - REACTIVIDAD AUTOM√ÅTICA (iOS 18.5+)
- ‚úÖ Usar `@Published` - SwiftUI se redibuja autom√°ticamente
- ‚ùå NO usar Timers para delays artificiales
- ‚ùå NO usar `Task.sleep` para esperas
- ‚ùå NO usar callbacks manuales (a menos que sea absolutamente necesario)
- ‚úÖ Usar nueva sintaxis de `onChange` - `{ oldValue, newValue in }`
- ‚úÖ Usar `@Observable` macro moderno (opcional)
- ‚úÖ Usar `NavigationStack` moderno

#### üñºÔ∏è PREVIEW MACRO - USO CORRECTO
- **#Preview es SOLO para SwiftUI Views**: ‚úÖ El macro `#Preview` est√° dise√±ado para previsualizar SwiftUI Views que conforman al protocolo `View`
- **ViewModels NO usan #Preview**: ‚ùå NO usar `#Preview` en ViewModels, Services, o cualquier clase que NO sea una SwiftUI View
- **Error com√∫n**: `'buildExpression' is unavailable: this expression does not conform to 'View'` ocurre cuando se intenta previsualizar un tipo no-View
- **Uso correcto**: 
  ```swift
  // ‚úÖ CORRECTO: En View files
  #Preview {
      MyView()
  }
  
  // ‚ùå INCORRECTO: En ViewModel files
  #Preview {
      MyViewModel()  // ¬°ERROR! ViewModel no es View
  }
  ```
- **Principio**: Solo previsualizar Views, nunca ViewModels o Services

### üÜï NUEVAS REGLAS MVVM APRENDIDAS HOY - OBLIGATORIAS

#### üîÑ GESTI√ìN DEL CICLO DE VIDA DEL VIEWMODEL
- **ViewModel Protocol**: ‚úÖ Debe conformar `ObservableObject`
- **@StateObject en Views**: ‚úÖ Usar `@StateObject` cuando la vista crea y posee el ViewModel
- **Beneficio**: Evita reinicializaci√≥n del ViewModel en cada redibujo, previene p√©rdida de estado
- **Ejemplo**: `@StateObject private var viewModel = UserListViewModel()`

#### üíâ INYECCI√ìN DE DEPENDENCIAS EN VIEWMODEL
- **Service Injection**: ‚úÖ ViewModel debe recibir service como par√°metro de inicializaci√≥n
- **Principio**: Dependency Injection para aislar l√≥gica de persistencia/red
- **Beneficio**: Facilita mocking en tests unitarios y separaci√≥n de responsabilidades
- **Ejemplo**:
```swift
init(service: UserServiceProtocol) {
    self.service = service
}
```

#### üìÅ ESTRUCTURA DEL PROYECTO - ORGANIZACI√ìN PARA ESCALABILIDAD
- **Directorio Base**: ‚úÖ Mantener para componentes reusables (ej. Loading)
- **Ruta sugerida**: `Base/View/Loading/Loading.swift`
- **Organizaci√≥n**: Separar claramente Views, ViewModels, Services, Models
- **Services Organization**: 
  - `Services/Protocols/` - Todos los protocolos de servicios
  - `Services/Implementation/` - Implementaciones concretas de servicios
  - `Services/CoreDataService.swift` - Clase base para servicios Core Data
- **ViewModels Organization**: 
  - `ViewModel/User/` - ViewModels relacionados con usuarios
  - `ViewModel/Group/` - ViewModels relacionados con grupos
  - `ViewModel/Entry/` - ViewModels relacionados con entradas
  - `ViewModel/Item/` - ViewModels relacionados con items
  - `ViewModel/Category/` - ViewModels relacionados con categor√≠as
- **Views Organization**: 
  - `View/User/` - Vistas relacionadas con usuarios
  - `View/Group/` - Vistas relacionadas con grupos
  - `View/Entry/` - Vistas relacionadas con entradas
  - `View/Base/` - Componentes reusables (Loading, etc.)

#### ‚ö° CONCURRENCIA Y ASINCRON√çA
- **Swift Concurrency**: ‚úÖ Usar `async/await` en lugar de callbacks anidados o Combine
- **Beneficios**:
  - C√≥digo m√°s limpio y legible
  - Manejo integrado de errores con `try/catch`
  - Evita errores de concurrencia al actualizar UI
- **@MainActor**: ‚úÖ Usar cuando sea necesario para operaciones de UI

#### üéØ RESUMEN DE ROLES
- **ViewModel**: `ObservableObject` que expone datos y l√≥gica a la vista
- **Service**: Encapsula acceso a datos (API, Core Data, etc.) y se inyecta en ViewModel
- **View**: Usa `@StateObject` para instanciar ViewModel y reaccionar a cambios

#### üöÄ OPTIMIZACIONES DE FLUIDEZ - DIFERENCIADORAS
- **@MainActor**: ‚úÖ Usar correctamente en propiedades que actualizan UI
- **Lazy Loading**: ‚úÖ Usar `LazyVStack`, `List` para vistas grandes
- **Procesamiento Pesado**: ‚ùå NO en cuerpo de vista, ‚úÖ TODO en ViewModel o Services
- **Caching**: ‚úÖ Cachear datos cuando tenga sentido (im√°genes, resultados Core Data)
- **Animaciones**: ‚úÖ Usar `withAnimation` y transiciones nativas SwiftUI

### üß≠ NAVEGACI√ìN MODERNA - OBLIGATORIA (iOS 18.5+)
- **NavigationStack**: ‚úÖ SIEMPRE usar NavigationStack en lugar de NavigationView
- **NavigationDestination**: ‚úÖ Definir destinos de navegaci√≥n con tipos espec√≠ficos
- **NavigationPath**: ‚úÖ Usar NavigationPath para gesti√≥n de estado de navegaci√≥n
- **NavigationLink**: ‚úÖ Usar NavigationLink para navegaci√≥n declarativa
- **Navegaci√≥n Program√°tica**: ‚úÖ Implementar `navigationPath.append()` para navegaci√≥n din√°mica

### üéØ MEJORES PR√ÅCTICAS DE NAVEGACI√ìN APRENDIDAS

#### üìã **IMPLEMENTACI√ìN COMPLETA PASO A PASO**

1. **PASO 1: Definir Enums de Navegaci√≥n en MainView**:
   ```swift
   // ‚úÖ CORRECTO: Definir todos los destinos en MainView
   enum CreateGroupDestination: Hashable {
       case createGroup(User)
   }
   
   enum SettingsDestination: Hashable {
       case settings
   }
   
   enum AddEntryDestination: Hashable {
       case addEntry(User, Group)
   }
   ```

2. **PASO 2: Configurar NavigationStack en MainView**:
   ```swift
   struct MainView: View {
       @State private var navigationPath = NavigationPath()
       
       var body: some View {
           NavigationStack(path: $navigationPath) {
               DetailedGroupView(navigationPath: $navigationPath)
                   
               // ‚úÖ CORRECTO: Definir TODOS los destinos aqu√≠
               .navigationDestination(for: CreateGroupDestination.self) { destination in
                   switch destination {
                   case .createGroup(let user):
                       CreateGroupView(user: user, navigationPath: $navigationPath)
                   }
               }
               .navigationDestination(for: SettingsDestination.self) { destination in
                   switch destination {
                   case .settings:
                       SettingsView(navigationPath: $navigationPath)
                   }
               }
               .navigationDestination(for: AddEntryDestination.self) { destination in
                   switch destination {
                   case .addEntry(let user, let group):
                       AddEntryView(user: user, group: group, navigationPath: $navigationPath)
                   }
               }
           }
       }
   }
   ```

3. **PASO 3: Pasar NavigationPath a Vistas Hijas**:
   ```swift
   // ‚úÖ CORRECTO: Pasar navigationPath como @Binding
   struct DetailedGroupView: View {
       @Binding var navigationPath: NavigationPath
       
       var body: some View {
           // Botones de navegaci√≥n
           Button("Crear Grupo") {
               if let selectedUser = viewModel.selectedUser {
                   navigationPath.append(CreateGroupDestination.createGroup(selectedUser))
               }
           }
           
           Button("Settings") {
               navigationPath.append(SettingsDestination.settings)
           }
           
           Button("Add Entry") {
               if let user = viewModel.selectedUser, let group = viewModel.selectedGroup {
                   navigationPath.append(AddEntryDestination.addEntry(user, group))
               }
           }
       }
   }
   ```

4. **PASO 4: Implementar Navegaci√≥n de Retorno en Vistas Destino**:
   ```swift
   struct CreateGroupView: View {
       @Binding var navigationPath: NavigationPath
       
       var body: some View {
           // ‚úÖ CORRECTO: Usar navigationPath.removeLast() para regresar
           Button("Cancelar") {
               navigationPath.removeLast()
           }
           
           // ‚úÖ CORRECTO: Regresar autom√°ticamente despu√©s de crear
           .onChange(of: viewModel.groupCreatedSuccessfully) { _, newValue in
               if newValue {
                   navigationPath.removeLast()
               }
           }
       }
   }
   ```

5. **PASO 5: Actualizar Datos al Regresar**:
   ```swift
   struct DetailedGroupView: View {
       var body: some View {
           // ‚úÖ CORRECTO: Refrescar datos cuando la vista aparezca
           .onAppear {
               Task {
                   await viewModel.loadData()
                   await viewModel.autoSelectFirstUserAndGroup()
               }
           }
       }
   }
   ```

#### üö´ **ERRORES COMUNES A EVITAR**

1. **NavigationStack Anidados**:
   ```swift
   // ‚ùå INCORRECTO: NO hacer esto
   NavigationStack {
       NavigationStack { }  // ¬°ERROR! Doble NavigationStack
   }
   ```

2. **Definir Destinos en M√∫ltiples Lugares**:
   ```swift
   // ‚ùå INCORRECTO: NO definir en DetailedGroupView
   .navigationDestination(for: CreateGroupDestination.self) { ... }
   
   // ‚úÖ CORRECTO: Solo en MainView
   ```

3. **Usar @Environment(\.dismiss)**:
   ```swift
   // ‚ùå INCORRECTO: NO usar esto
   @Environment(\.dismiss) private var dismiss
   
   // ‚úÖ CORRECTO: Usar navigationPath.removeLast()
   @Binding var navigationPath: NavigationPath
   ```

4. **Sheets para Navegaci√≥n**:
   ```swift
   // ‚ùå INCORRECTO: NO usar sheets
   .sheet(isPresented: $showingCreateGroup) { ... }
   
   // ‚úÖ CORRECTO: Usar NavigationStack
   navigationPath.append(CreateGroupDestination.createGroup(user))
   ```

#### üîÑ **PATR√ìN COMPLETO DE IMPLEMENTACI√ìN**

1. **MainView**: Define NavigationStack y todos los NavigationDestination
2. **Vistas Hijas**: Reciben `@Binding var navigationPath: NavigationPath`
3. **Botones**: Usan `navigationPath.append(Destination.enumCase(data))`
4. **Vistas Destino**: Usan `navigationPath.removeLast()` para regresar
5. **Retorno**: Implementar `.onAppear` para refrescar datos si es necesario

#### üì± **COMPATIBILIDAD iOS 18.5+**

- ‚úÖ `NavigationStack` (reemplaza NavigationView)
- ‚úÖ `NavigationDestination` (navegaci√≥n tipo-segura)
- ‚úÖ `NavigationPath` (gesti√≥n de estado de navegaci√≥n)
- ‚úÖ `onChange` con nueva sintaxis `{ oldValue, newValue in }`
- ‚úÖ `@MainActor` para ViewModels
- ‚úÖ `async/await` para operaciones as√≠ncronas

#### üéØ **REGLAS DE ORO FINALES**

1. **Un solo NavigationStack** en MainView
2. **NavigationPath compartido** entre todas las vistas
3. **Enums tipados** para todos los destinos de navegaci√≥n
4. **Sin NavigationStacks anidados** ni sheets para navegaci√≥n
5. **Actualizaci√≥n de datos** al regresar usando `.onAppear`
6. **Navegaci√≥n program√°tica** con `navigationPath.append()`
7. **Retorno program√°tico** con `navigationPath.removeLast()`

### ‚ö° SWIFT CONCURRENCY AVANZADO - OBLIGATORIO
- **async/await**: ‚úÖ SIEMPRE usar async/await en lugar de callbacks o Combine
- **Task**: ‚úÖ Usar Task para operaciones as√≠ncronas desde Views
- **@MainActor**: ‚úÖ Usar @MainActor para ViewModels que actualizan UI
- **Background Context**: ‚úÖ Usar `context.perform` para operaciones Core Data
- **Error Handling**: ‚úÖ Implementar try/catch con manejo de errores apropiado
- **Patr√≥n de Concurrencia**:
```swift
// ‚úÖ CORRECTO: Operaci√≥n en background, UI en main
func createGroup() async {
    isLoading = true
    
    do {
        let newGroup = try await groupService.createGroup(name: name, currency: currency)
        await MainActor.run {
            groups.append(newGroup)
            isLoading = false
        }
    } catch {
        await MainActor.run {
            errorMessage = error.localizedDescription
            isLoading = false
        }
    }
}
```

### üö´ PROHIBIDO
- Operaciones pesadas en main thread
- L√≥gica de negocio en Views
- UI elements en ViewModels
- Delays artificiales o polling
- ViewModels sin Dependency Injection
- Views sin @StateObject para ViewModels propios
- ViewModels sin protocolo ObservableObject
- Falta de lazy loading en listas grandes
- Falta de caching para datos frecuentes
- Falta de animaciones suaves
- **üö® SHEETS - PROHIBIDOS A MENOS QUE SE SOLICITE ESPEC√çFICAMENTE**
  - ‚ùå NO usar `.sheet()` para modales
  - ‚ùå NO usar `.fullScreenCover()` para pantallas completas
  - ‚úÖ SIEMPRE usar `NavigationStack` con `NavigationDestination`
  - ‚úÖ SIEMPRE usar `NavigationLink` para navegaci√≥n
  - ‚úÖ SIEMPRE usar `NavigationPath` para gesti√≥n de estado de navegaci√≥n
  - ‚úÖ SIEMPRE implementar navegaci√≥n program√°tica con `navigationPath.append()`
  - ‚úÖ SIEMPRE usar `@State private var navigationPath = NavigationPath()`
  - ‚úÖ SIEMPRE usar `NavigationStack(path: $navigationPath)` para navegaci√≥n compleja

### üÜï NUEVAS REGLAS APRENDIDAS - OBLIGATORIAS

#### üîí PREVENCI√ìN DE EJECUCIONES M√öLTIPLES
- **Flags de protecci√≥n**: ‚úÖ Usar flags booleanos para evitar ejecuciones simult√°neas de funciones async
- **Problema identificado**: Ejecuciones m√∫ltiples causan estado inconsistente en Core Data y bucles infinitos
- **Soluci√≥n implementada**: 
```swift
private var isAutoSelecting = false

func autoSelectFirstUserAndGroup() async {
    guard !isAutoSelecting else {
        print("‚ö†Ô∏è autoSelectFirstUserAndGroup ya est√° en ejecuci√≥n, saltando...")
        return
    }
    
    isAutoSelecting = true
    // ... c√≥digo de la funci√≥n ...
    isAutoSelecting = false
}
```

#### üóÑÔ∏è VALIDACIONES DE CORE DATA - SIMPLIFICADAS
- **NO validar manualmente**: ‚ùå NO usar `objectID.isTemporaryID` ni verificaciones complejas de estado
- **Confiar en Core Data**: ‚úÖ Dejar que Core Data maneje su propio estado internamente
- **Validaciones m√≠nimas**: ‚úÖ Solo verificar que objetos existan (`object != nil`), no su estado interno
- **Error com√∫n**: `'-[Group isTemporaryID]: unrecognized selector sent to instance'`
- **Soluci√≥n**: Eliminar verificaciones de `isDeleted`, `isTemporaryID` y confiar en la reactividad de SwiftUI

#### üéØ PATR√ìN MVVM PURO - SIN INTERRUPCIONES MANUALES
- **Reactividad autom√°tica**: ‚úÖ Usar `@Published` y dejar que SwiftUI espere naturalmente
- **Sin delays artificiales**: ‚ùå NO usar `Task.sleep`, `Task.yield` ni pausas manuales
- **Flujo natural**: ‚úÖ La vista espera autom√°ticamente a que los datos est√©n listos
- **Principio**: "La vista espera naturalmente usando @Published, no interrumpimos el flujo"

#### üîÑ GESTI√ìN DE ESTADO ESTABLE
- **Flags de protecci√≥n**: ‚úÖ Implementar en funciones cr√≠ticas como `loadData()` y `autoSelectFirstUserAndGroup()`
- **Estado consistente**: ‚úÖ Evitar que m√∫ltiples operaciones modifiquen el mismo estado simult√°neamente
- **Logs de debug**: ‚úÖ Agregar logs detallados para identificar problemas de concurrencia
- **Patr√≥n recomendado**: 
```swift
private var isOperationInProgress = false

func criticalOperation() async {
    guard !isOperationInProgress else { return }
    isOperationInProgress = true
    // ... operaci√≥n cr√≠tica ...
    isOperationInProgress = false
}
```

## Project Overview
Building a native iOS personal expense tracker app using SwiftUI (iOS 18.5+) with strict MVVM architecture, Core Data persistence, and NavigationStack navigation building into the view model for simplicity.

## Development Strategy
- **Incremental Development**: Small, focused commits for each feature
- **MVVM First**: All business logic in ViewModels, Views only display
- **Core Data Foundation**: Start with data model, build UI on top
- **Test-Driven**: Unit tests for each component
- **Physical Device Testing**: Always test on physical device, not simulator
- **Device ID**: ALWAYS use "Dennis's iPhone (18.6) (00008120-000A190218614032)" for all testing and build
- **Dependency Injection**: Services injected into ViewModels for testability
- **Lifecycle Management**: Proper @StateObject usage for ViewModel persistence

### Performance Considerations
- Use background queues for Core Data operations
- Implement proper error handling
- Optimize for smooth UI updates
- Follow Apple's native UI/UX conventions
- Use lazy loading for large lists and views
- Cache frequently accessed data
- Implement smooth animations and transitions

Para empezar 

Genera el modelo de datos de Core Data en Swift usando NSManagedObject para cada entidad descrita a continuaci√≥n, junto con su correspondiente ViewModel siguiendo la arquitectura MVVM.

## üÜï REQUISITOS DE ARQUITECTURA ACTUALIZADOS

### üìÅ Estructura del Proyecto
- **Model/**: Entidades Core Data
- **ViewModel/**: ViewModels con inyecci√≥n de dependencias
- **Service/**: Capa de servicios para operaciones CRUD
- **View/**: Vistas SwiftUI
- **Base/**: Componentes reusables (Loading, etc.)

### üèóÔ∏è Modelo (Model/)
- **IMPORTANTE**: Las entidades est√°n configuradas con "Codegen: Class Definition" en Xcode
- **NO crear archivos manuales**: Xcode genera autom√°ticamente las clases Core Data en tiempo de compilaci√≥n
- **Verificar configuraci√≥n**: Cada entidad en .xcdatamodel debe tener "Codegen: Class Definition"
- **Entidades generadas autom√°ticamente**: User, Group, Entry, Item, Category, UserGroup
- **Tipos correctos**: UUID?, Date?, NSDecimalNumber?, Int32, String?, Set<Entity>?
- **Relaciones**: Ya configuradas en .xcdatamodel con delete rules apropiadas

### üíâ Vista Modelo (ViewModel/) - ACTUALIZADO
- **Crear un ViewModel por entidad que sea ObservableObject**
- **Incluir un @Published array de la entidad ([Entity]) para la lista de resultados**
- **Incluir un inicializador que reciba Service como par√°metro (Dependency Injection)**
- **Implementar m√©todos CRUD (create, fetch, update, delete) para interactuar con Core Data**
- **Gestionar errores y usar try? context.save() de forma segura**
- **ViewModels deben exponer datos ya formateados para uso en SwiftUI (por ejemplo, fecha como String)**
- **Usar @MainActor para operaciones de UI**
- **Implementar lazy loading para listas grandes**
- **Implementar caching para datos frecuentemente accedidos**

### üîß Service Layer - NUEVO
- **Crear un Service por entidad que maneje operaciones CRUD**
- **Services deben ser inyectados en ViewModels**
- **Implementar protocols para cada Service (ej: UserServiceProtocol)**
- **Usar background queues para operaciones Core Data**
- **Retornar resultados al main thread para actualizaciones de UI**

### üëÅÔ∏è Vista (View/)
- **No es necesario generar vistas completas, pero los ViewModels deben estar listos para enlazarse con SwiftUI**
- **Usar @StateObject para ViewModels que la vista posee**
- **Implementar lazy loading con LazyVStack y List**
- **Usar withAnimation para transiciones suaves**

## Estilo de c√≥digo
- Swift 5, Xcode 16+ compatible
- Nombrado limpio y consistente con Swift
- Evitar force unwrap (!)
- Incluir comentarios claros para cada relaci√≥n explicando el deleteRule
- Separar carpetas Model/, ViewModel/, Service/, View/, y Base/
- **Usar async/await para operaciones as√≠ncronas**
- **Implementar proper error handling con try/catch**
- **Usar @MainActor para operaciones de UI**

## Entidades y atributos:
Category
- id: UUID,
- name: String, default ""
- color: String?, optional, default "#8E8E93"
- createdAt: Date?, optional
- lastModifiedAt: Date?, optional
- Relaciones:
  - entries: Set<Entry>?, to-many, inverse category, delete rule Nullify
  - group: Group?, to-one, inverse categories, delete rule Cascade

Entry
- id: UUID,
- description: String?, optional, default ""
- date: Date,
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- categoryId: UUID,
- groupId: UUID,
- Relaciones:
  - category: Category?, to-one, inverse entries, delete rule Nullify
  - group: Group?, to-one, inverse entries, delete rule Nullify
  - items: Set<Item>?, to-many, inverse entry, delete rule Cascade

Group
- id: UUID,
- name: String?, optional, default ""
- currency: String?, optional, default "USD"
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - entries: Set<Entry>?, to-many, inverse group, delete rule Cascade
  - categories: Set<Category>?, to-many, inverse group, delete rule Cascade
  - userGroups: Set<UserGroup>?, to-many, inverse group, delete rule Cascade

Item
- id: UUID,
- description: String?, optional, default ""
- amount: NSDecimalNumber?, optional, default 0.0
- quantity: Int32, optional, default 1
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - entry: Entry?, to-one, inverse items, delete rule Nullify

User
- id: UUID?, optional
- name: String?, optional, default ""
- email: String,
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - userGroups: Set<UserGroup>?, to-many, inverse user, delete rule Cascade

UserGroup
- id: UUID,
- role: String?, optional, default "owner"
- joinedAt: Date?, optional auto generated
- userId: UUID,
- groupId: UUID,
- Relaciones:
  - user: User?, to-one, inverse userGroups, delete rule Cascade
  - group: Group?, to-one, inverse userGroups, delete rule Cascade

## üÜï Requisitos adicionales actualizados:
- **IMPORTANTE**: Las entidades Core Data est√°n configuradas con "Codegen: Class Definition" en Xcode
- **NO crear archivos manuales**: Xcode genera autom√°ticamente las clases Core Data en tiempo de compilaci√≥n
- **Implementa Service layer con protocols para cada entidad**
- **ViewModels deben recibir Services como par√°metros de inicializaci√≥n**
- **Usa @StateObject en Views para ViewModels propios**
- **Implementa lazy loading y caching para performance**
- **Usa async/await para operaciones as√≠ncronas**
- **Implementa proper error handling con try/catch**
- **Usa @MainActor para operaciones de UI**
- **Implementa animaciones suaves con withAnimation**

## üèóÔ∏è **ESTRUCTURA DE DIRECTORIOS OBLIGATORIA PARA ESCALABILIDAD**

### **Services/**
```
Services/
‚îú‚îÄ‚îÄ Protocols/              # Protocolos de servicios para DI
‚îÇ   ‚îú‚îÄ‚îÄ UserServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ GroupServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ EntryServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ ItemServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ CategoryServiceProtocol.swift
‚îÇ   ‚îî‚îÄ‚îÄ UserGroupServiceProtocol.swift
‚îú‚îÄ‚îÄ Implementation/         # Implementaciones concretas
‚îÇ   ‚îú‚îÄ‚îÄ UserService.swift
‚îÇ   ‚îú‚îÄ‚îÄ GroupService.swift
‚îÇ   ‚îú‚îÄ‚îÄ EntryService.swift
‚îÇ   ‚îú‚îÄ‚îÄ ItemService.swift
‚îÇ   ‚îú‚îÄ‚îÄ CategoryService.swift
‚îÇ   ‚îî‚îÄ‚îÄ UserGroupService.swift
‚îî‚îÄ‚îÄ CoreDataService.swift   # Clase base para servicios
```

### **ViewModels/**
```
ViewModel/
‚îú‚îÄ‚îÄ User/                   # ViewModels relacionados con usuarios
‚îú‚îÄ‚îÄ Group/                  # ViewModels relacionados con grupos
‚îú‚îÄ‚îÄ Entry/                  # ViewModels relacionados con entradas
‚îú‚îÄ‚îÄ Item/                   # ViewModels relacionados con items
‚îî‚îÄ‚îÄ Category/               # ViewModels relacionados con categor√≠as
```

### **Views/**
```
View/
‚îú‚îÄ‚îÄ User/                   # Vistas relacionadas con usuarios
‚îú‚îÄ‚îÄ Group/                  # Vistas relacionadas con grupos
‚îú‚îÄ‚îÄ Entry/                  # Vistas relacionadas con entradas
‚îî‚îÄ‚îÄ Base/                   # Componentes reusables (Loading, etc.)
```

### **Imports en Swift - IMPORTANTE**
- **NO usar @_exported import**: En Swift, cuando todos los archivos est√°n en el mismo target, son autom√°ticamente visibles
- **Imports autom√°ticos**: Los protocolos y clases se importan autom√°ticamente dentro del mismo m√≥dulo
- **Mantener imports b√°sicos**: Solo `import Foundation` e `import CoreData` son necesarios
- **Simplicidad**: No necesitamos archivos de imports centralizados en Swift
- **Uso de protocolos**: Usar `any ProtocolName` para evitar warnings de Swift

## üö® RECORDATORIOS CR√çTICOS - REVISAR ANTES DE CADA IMPLEMENTACI√ìN

### ‚úÖ VERIFICAR ANTES DE IMPLEMENTAR:
1. **Views**: ¬øSolo contienen SwiftUI Views sin l√≥gica?
2. **ViewModels**: ¬øSolo contienen l√≥gica de negocio sin UI?
3. **Threading**: ¬øOperaciones pesadas en background, UI en main?
4. **@Published**: ¬øSe usa para reactividad autom√°tica?
5. **@MainActor**: ¬øSe usa en ViewModels para operaciones de UI?
6. **Delays**: ¬øNO hay Timers o delays artificiales?
7. **iOS 18.5+**: ¬øSe usan APIs modernas, no deprecadas?
8. **onChange**: ¬øSe usa nueva sintaxis `{ oldValue, newValue in }`?
9. **@StateObject**: ¬øSe usa para ViewModels que la vista posee?
10. **Dependency Injection**: ¬øLos ViewModels reciben services como par√°metros?
11. **ObservableObject**: ¬øTodos los ViewModels conforman el protocolo?
12. **Lazy Loading**: ¬øSe usa para listas y vistas grandes?
13. **Caching**: ¬øSe implementa para datos frecuentemente accedidos?
14. **Animations**: ¬øSe usan withAnimation y transiciones nativas?

### üéØ OBJETIVO FINAL
**UI completamente fluida, sin bloqueos, con operaciones pesadas ejecut√°ndose en background y actualizaciones autom√°ticas en main thread usando la reactividad autom√°tica de SwiftUI, implementando las mejores pr√°cticas MVVM aprendidas hoy.**

---

**RECUERDA: Cada l√≠nea de c√≥digo debe seguir estas reglas estrictas. La arquitectura MVVM, el threading correcto, la inyecci√≥n de dependencias, y la gesti√≥n del ciclo de vida del ViewModel son OBLIGATORIOS para mantener la fluidez de la UI y la mantenibilidad del c√≥digo.**
