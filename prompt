Prompt para Cursor:
# OMOMoney - SwiftUI Expense Tracker App Development

## üö® REGLAS ESTRICTAS DE DESARROLLO - OBLIGATORIAS

### üì± VERSI√ìN DE PLATAFORMA - OBLIGATORIO
- **iOS Target**: iOS 18.5+ (2025)
- **SwiftUI**: Usar APIs m√°s modernas disponibles
- **Compatibilidad**: No usar APIs deprecadas

### üèóÔ∏è ARQUITECTURA MVVM - NO NEGOCIABLE
- **Views**: ‚ùå NO contienen l√≥gica, ‚ùå NO c√°lculos, ‚ùå NO formateo, ‚úÖ SOLO SwiftUI Views
- **ViewModels**: ‚ùå NO contienen UI, ‚úÖ SOLO l√≥gica de presentaci√≥n, ‚úÖ @MainActor, ‚úÖ @Published
- **Services**: ‚úÖ SOLO l√≥gica CRUD y operaciones de datos, ‚úÖ NO l√≥gica de presentaci√≥n
- **Models**: ‚ùå NO contienen l√≥gica, ‚úÖ SOLO entidades Core Data

### üßµ THREADING - CR√çTICO
- **Main Thread**: ‚úÖ SOLO UI, ‚úÖ navegaci√≥n, ‚úÖ gestos, ‚úÖ animaciones
- **Background Thread**: ‚úÖ Core Data CRUD, ‚úÖ c√°lculos complejos, ‚úÖ filtros pesados
- **Patr√≥n obligatorio**: `DispatchQueue.global` ‚Üí operaci√≥n pesada ‚Üí `DispatchQueue.main.async`

### üì± SWIFTUI - REACTIVIDAD AUTOM√ÅTICA (iOS 18.5+)
- ‚úÖ Usar `@Published` - SwiftUI se redibuja autom√°ticamente
- ‚ùå NO usar Timers para delays artificiales
- ‚ùå NO usar `Task.sleep` para esperas
- ‚ùå NO usar callbacks manuales (a menos que sea absolutamente necesario)
- ‚úÖ Usar nueva sintaxis de `onChange` - `{ oldValue, newValue in }`
- ‚úÖ Usar `@Observable` macro moderno (opcional)
- ‚úÖ Usar `NavigationStack` moderno

### üÜï NUEVAS REGLAS MVVM APRENDIDAS HOY - OBLIGATORIAS

#### üîÑ GESTI√ìN DEL CICLO DE VIDA DEL VIEWMODEL
- **ViewModel Protocol**: ‚úÖ Debe conformar `ObservableObject`
- **@StateObject en Views**: ‚úÖ Usar `@StateObject` cuando la vista crea y posee el ViewModel
- **Beneficio**: Evita reinicializaci√≥n del ViewModel en cada redibujo, previene p√©rdida de estado
- **Ejemplo**: `@StateObject private var viewModel = UserListViewModel()`

#### üíâ INYECCI√ìN DE DEPENDENCIAS EN VIEWMODEL
- **Service Injection**: ‚úÖ ViewModel debe recibir service como par√°metro de inicializaci√≥n
- **Principio**: Dependency Injection para aislar l√≥gica de persistencia/red
- **Beneficio**: Facilita mocking en tests unitarios y separaci√≥n de responsabilidades
- **Ejemplo**:
```swift
init(service: UserServiceProtocol) {
    self.service = service
}
```

#### üìÅ ESTRUCTURA DEL PROYECTO - ORGANIZACI√ìN PARA ESCALABILIDAD
- **Directorio Base**: ‚úÖ Mantener para componentes reusables (ej. Loading)
- **Ruta sugerida**: `Base/View/Loading/Loading.swift`
- **Organizaci√≥n**: Separar claramente Views, ViewModels, Services, Models
- **Services Organization**: 
  - `Services/Protocols/` - Todos los protocolos de servicios
  - `Services/Implementation/` - Implementaciones concretas de servicios
  - `Services/CoreDataService.swift` - Clase base para servicios Core Data
- **ViewModels Organization**: 
  - `ViewModel/User/` - ViewModels relacionados con usuarios
  - `ViewModel/Group/` - ViewModels relacionados con grupos
  - `ViewModel/Entry/` - ViewModels relacionados con entradas
  - `ViewModel/Item/` - ViewModels relacionados con items
  - `ViewModel/Category/` - ViewModels relacionados con categor√≠as
- **Views Organization**: 
  - `View/User/` - Vistas relacionadas con usuarios
  - `View/Group/` - Vistas relacionadas con grupos
  - `View/Entry/` - Vistas relacionadas con entradas
  - `View/Base/` - Componentes reusables (Loading, etc.)

#### ‚ö° CONCURRENCIA Y ASINCRON√çA
- **Swift Concurrency**: ‚úÖ Usar `async/await` en lugar de callbacks anidados o Combine
- **Beneficios**:
  - C√≥digo m√°s limpio y legible
  - Manejo integrado de errores con `try/catch`
  - Evita errores de concurrencia al actualizar UI
- **@MainActor**: ‚úÖ Usar cuando sea necesario para operaciones de UI

#### üéØ RESUMEN DE ROLES
- **ViewModel**: `ObservableObject` que expone datos y l√≥gica a la vista
- **Service**: Encapsula acceso a datos (API, Core Data, etc.) y se inyecta en ViewModel
- **View**: Usa `@StateObject` para instanciar ViewModel y reaccionar a cambios

#### üöÄ OPTIMIZACIONES DE FLUIDEZ - DIFERENCIADORAS
- **@MainActor**: ‚úÖ Usar correctamente en propiedades que actualizan UI
- **Lazy Loading**: ‚úÖ Usar `LazyVStack`, `List` para vistas grandes
- **Procesamiento Pesado**: ‚ùå NO en cuerpo de vista, ‚úÖ TODO en ViewModel o Services
- **Caching**: ‚úÖ Cachear datos cuando tenga sentido (im√°genes, resultados Core Data)
- **Animaciones**: ‚úÖ Usar `withAnimation` y transiciones nativas SwiftUI

### üö´ PROHIBIDO
- Operaciones pesadas en main thread
- L√≥gica de negocio en Views
- UI elements en ViewModels
- Delays artificiales o polling
- ViewModels sin Dependency Injection
- Views sin @StateObject para ViewModels propios
- ViewModels sin protocolo ObservableObject
- Falta de lazy loading en listas grandes
- Falta de caching para datos frecuentes
- Falta de animaciones suaves

## Project Overview
Building a native iOS personal expense tracker app using SwiftUI (iOS 18.5+) with strict MVVM architecture, Core Data persistence, and NavigationStack navigation building into the view model for simplicity.

## Development Strategy
- **Incremental Development**: Small, focused commits for each feature
- **MVVM First**: All business logic in ViewModels, Views only display
- **Core Data Foundation**: Start with data model, build UI on top
- **Test-Driven**: Unit tests for each component
- **Physical Device Testing**: Always test on physical device, not simulator
- **Device ID**: ALWAYS use "Dennis's iPhone (18.6) (00008120-000A190218614032)" for all testing and build
- **Dependency Injection**: Services injected into ViewModels for testability
- **Lifecycle Management**: Proper @StateObject usage for ViewModel persistence

### Performance Considerations
- Use background queues for Core Data operations
- Implement proper error handling
- Optimize for smooth UI updates
- Follow Apple's native UI/UX conventions
- Use lazy loading for large lists and views
- Cache frequently accessed data
- Implement smooth animations and transitions

Para empezar 

Genera el modelo de datos de Core Data en Swift usando NSManagedObject para cada entidad descrita a continuaci√≥n, junto con su correspondiente ViewModel siguiendo la arquitectura MVVM.

## üÜï REQUISITOS DE ARQUITECTURA ACTUALIZADOS

### üìÅ Estructura del Proyecto
- **Model/**: Entidades Core Data
- **ViewModel/**: ViewModels con inyecci√≥n de dependencias
- **Service/**: Capa de servicios para operaciones CRUD
- **View/**: Vistas SwiftUI
- **Base/**: Componentes reusables (Loading, etc.)

### üèóÔ∏è Modelo (Model/)
- **IMPORTANTE**: Las entidades est√°n configuradas con "Codegen: Class Definition" en Xcode
- **NO crear archivos manuales**: Xcode genera autom√°ticamente las clases Core Data en tiempo de compilaci√≥n
- **Verificar configuraci√≥n**: Cada entidad en .xcdatamodel debe tener "Codegen: Class Definition"
- **Entidades generadas autom√°ticamente**: User, Group, Entry, Item, Category, UserGroup
- **Tipos correctos**: UUID?, Date?, NSDecimalNumber?, Int32, String?, Set<Entity>?
- **Relaciones**: Ya configuradas en .xcdatamodel con delete rules apropiadas

### üíâ Vista Modelo (ViewModel/) - ACTUALIZADO
- **Crear un ViewModel por entidad que sea ObservableObject**
- **Incluir un @Published array de la entidad ([Entity]) para la lista de resultados**
- **Incluir un inicializador que reciba Service como par√°metro (Dependency Injection)**
- **Implementar m√©todos CRUD (create, fetch, update, delete) para interactuar con Core Data**
- **Gestionar errores y usar try? context.save() de forma segura**
- **ViewModels deben exponer datos ya formateados para uso en SwiftUI (por ejemplo, fecha como String)**
- **Usar @MainActor para operaciones de UI**
- **Implementar lazy loading para listas grandes**
- **Implementar caching para datos frecuentemente accedidos**

### üîß Service Layer - NUEVO
- **Crear un Service por entidad que maneje operaciones CRUD**
- **Services deben ser inyectados en ViewModels**
- **Implementar protocols para cada Service (ej: UserServiceProtocol)**
- **Usar background queues para operaciones Core Data**
- **Retornar resultados al main thread para actualizaciones de UI**

### üëÅÔ∏è Vista (View/)
- **No es necesario generar vistas completas, pero los ViewModels deben estar listos para enlazarse con SwiftUI**
- **Usar @StateObject para ViewModels que la vista posee**
- **Implementar lazy loading con LazyVStack y List**
- **Usar withAnimation para transiciones suaves**

## Estilo de c√≥digo
- Swift 5, Xcode 16+ compatible
- Nombrado limpio y consistente con Swift
- Evitar force unwrap (!)
- Incluir comentarios claros para cada relaci√≥n explicando el deleteRule
- Separar carpetas Model/, ViewModel/, Service/, View/, y Base/
- **Usar async/await para operaciones as√≠ncronas**
- **Implementar proper error handling con try/catch**
- **Usar @MainActor para operaciones de UI**

## Entidades y atributos:
Category
- id: UUID,
- name: String, default ""
- color: String?, optional, default "#8E8E93"
- createdAt: Date?, optional
- lastModifiedAt: Date?, optional
- Relaciones:
  - entries: Set<Entry>?, to-many, inverse category, delete rule Nullify
  - group: Group?, to-one, inverse categories, delete rule Cascade

Entry
- id: UUID,
- description: String?, optional, default ""
- date: Date,
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- categoryId: UUID,
- groupId: UUID,
- Relaciones:
  - category: Category?, to-one, inverse entries, delete rule Nullify
  - group: Group?, to-one, inverse entries, delete rule Nullify
  - items: Set<Item>?, to-many, inverse entry, delete rule Cascade

Group
- id: UUID,
- name: String?, optional, default ""
- currency: String?, optional, default "USD"
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - entries: Set<Entry>?, to-many, inverse group, delete rule Cascade
  - categories: Set<Category>?, to-many, inverse group, delete rule Cascade
  - userGroups: Set<UserGroup>?, to-many, inverse group, delete rule Cascade

Item
- id: UUID,
- description: String?, optional, default ""
- amount: NSDecimalNumber?, optional, default 0.0
- quantity: Int32, optional, default 1
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - entry: Entry?, to-one, inverse items, delete rule Nullify

User
- id: UUID?, optional
- name: String?, optional, default ""
- email: String,
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - userGroups: Set<UserGroup>?, to-many, inverse user, delete rule Cascade

UserGroup
- id: UUID,
- role: String?, optional, default "owner"
- joinedAt: Date?, optional auto generated
- userId: UUID,
- groupId: UUID,
- Relaciones:
  - user: User?, to-one, inverse userGroups, delete rule Cascade
  - group: Group?, to-one, inverse userGroups, delete rule Cascade

## üÜï Requisitos adicionales actualizados:
- **IMPORTANTE**: Las entidades Core Data est√°n configuradas con "Codegen: Class Definition" en Xcode
- **NO crear archivos manuales**: Xcode genera autom√°ticamente las clases Core Data en tiempo de compilaci√≥n
- **Implementa Service layer con protocols para cada entidad**
- **ViewModels deben recibir Services como par√°metros de inicializaci√≥n**
- **Usa @StateObject en Views para ViewModels propios**
- **Implementa lazy loading y caching para performance**
- **Usa async/await para operaciones as√≠ncronas**
- **Implementa proper error handling con try/catch**
- **Usa @MainActor para operaciones de UI**
- **Implementa animaciones suaves con withAnimation**

## üèóÔ∏è **ESTRUCTURA DE DIRECTORIOS OBLIGATORIA PARA ESCALABILIDAD**

### **Services/**
```
Services/
‚îú‚îÄ‚îÄ Protocols/              # Protocolos de servicios para DI
‚îÇ   ‚îú‚îÄ‚îÄ UserServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ GroupServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ EntryServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ ItemServiceProtocol.swift
‚îÇ   ‚îú‚îÄ‚îÄ CategoryServiceProtocol.swift
‚îÇ   ‚îî‚îÄ‚îÄ UserGroupServiceProtocol.swift
‚îú‚îÄ‚îÄ Implementation/         # Implementaciones concretas
‚îÇ   ‚îú‚îÄ‚îÄ UserService.swift
‚îÇ   ‚îú‚îÄ‚îÄ GroupService.swift
‚îÇ   ‚îú‚îÄ‚îÄ EntryService.swift
‚îÇ   ‚îú‚îÄ‚îÄ ItemService.swift
‚îÇ   ‚îú‚îÄ‚îÄ CategoryService.swift
‚îÇ   ‚îî‚îÄ‚îÄ UserGroupService.swift
‚îî‚îÄ‚îÄ CoreDataService.swift   # Clase base para servicios
```

### **ViewModels/**
```
ViewModel/
‚îú‚îÄ‚îÄ User/                   # ViewModels relacionados con usuarios
‚îú‚îÄ‚îÄ Group/                  # ViewModels relacionados con grupos
‚îú‚îÄ‚îÄ Entry/                  # ViewModels relacionados con entradas
‚îú‚îÄ‚îÄ Item/                   # ViewModels relacionados con items
‚îî‚îÄ‚îÄ Category/               # ViewModels relacionados con categor√≠as
```

### **Views/**
```
View/
‚îú‚îÄ‚îÄ User/                   # Vistas relacionadas con usuarios
‚îú‚îÄ‚îÄ Group/                  # Vistas relacionadas con grupos
‚îú‚îÄ‚îÄ Entry/                  # Vistas relacionadas con entradas
‚îî‚îÄ‚îÄ Base/                   # Componentes reusables (Loading, etc.)
```

### **Imports en Swift - IMPORTANTE**
- **NO usar @_exported import**: En Swift, cuando todos los archivos est√°n en el mismo target, son autom√°ticamente visibles
- **Imports autom√°ticos**: Los protocolos y clases se importan autom√°ticamente dentro del mismo m√≥dulo
- **Mantener imports b√°sicos**: Solo `import Foundation` e `import CoreData` son necesarios
- **Simplicidad**: No necesitamos archivos de imports centralizados en Swift
- **Uso de protocolos**: Usar `any ProtocolName` para evitar warnings de Swift

## üö® RECORDATORIOS CR√çTICOS - REVISAR ANTES DE CADA IMPLEMENTACI√ìN

### ‚úÖ VERIFICAR ANTES DE IMPLEMENTAR:
1. **Views**: ¬øSolo contienen SwiftUI Views sin l√≥gica?
2. **ViewModels**: ¬øSolo contienen l√≥gica de negocio sin UI?
3. **Threading**: ¬øOperaciones pesadas en background, UI en main?
4. **@Published**: ¬øSe usa para reactividad autom√°tica?
5. **@MainActor**: ¬øSe usa en ViewModels para operaciones de UI?
6. **Delays**: ¬øNO hay Timers o delays artificiales?
7. **iOS 18.5+**: ¬øSe usan APIs modernas, no deprecadas?
8. **onChange**: ¬øSe usa nueva sintaxis `{ oldValue, newValue in }`?
9. **@StateObject**: ¬øSe usa para ViewModels que la vista posee?
10. **Dependency Injection**: ¬øLos ViewModels reciben services como par√°metros?
11. **ObservableObject**: ¬øTodos los ViewModels conforman el protocolo?
12. **Lazy Loading**: ¬øSe usa para listas y vistas grandes?
13. **Caching**: ¬øSe implementa para datos frecuentemente accedidos?
14. **Animations**: ¬øSe usan withAnimation y transiciones nativas?

### üéØ OBJETIVO FINAL
**UI completamente fluida, sin bloqueos, con operaciones pesadas ejecut√°ndose en background y actualizaciones autom√°ticas en main thread usando la reactividad autom√°tica de SwiftUI, implementando las mejores pr√°cticas MVVM aprendidas hoy.**

---

**RECUERDA: Cada l√≠nea de c√≥digo debe seguir estas reglas estrictas. La arquitectura MVVM, el threading correcto, la inyecci√≥n de dependencias, y la gesti√≥n del ciclo de vida del ViewModel son OBLIGATORIOS para mantener la fluidez de la UI y la mantenibilidad del c√≥digo.**
