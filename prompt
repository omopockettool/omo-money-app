Prompt para Cursor:
# OMOMoney - SwiftUI Expense Tracker App Development

## ğŸš¨ REGLAS ESTRICTAS DE DESARROLLO - OBLIGATORIAS

### ğŸ“± VERSIÃ“N DE PLATAFORMA - OBLIGATORIO
- **iOS Target**: iOS 18.5+ (2025)
- **SwiftUI**: Usar APIs mÃ¡s modernas disponibles
- **Compatibilidad**: No usar APIs deprecadas

### ğŸ—ï¸ ARQUITECTURA MVVM - NO NEGOCIABLE
- **Views**: âŒ NO contienen lÃ³gica, âŒ NO cÃ¡lculos, âŒ NO formateo, âœ… SOLO SwiftUI Views
- **ViewModels**: âŒ NO contienen UI, âœ… SOLO lÃ³gica de presentaciÃ³n, âœ… @MainActor, âœ… @Published
- **Services**: âœ… SOLO lÃ³gica CRUD y operaciones de datos, âœ… NO lÃ³gica de presentaciÃ³n
- **Models**: âŒ NO contienen lÃ³gica, âœ… SOLO entidades Core Data

### ğŸ§µ THREADING - CRÃTICO
- **Main Thread**: âœ… SOLO UI, âœ… navegaciÃ³n, âœ… gestos, âœ… animaciones
- **Background Thread**: âœ… Core Data CRUD, âœ… cÃ¡lculos complejos, âœ… filtros pesados
- **PatrÃ³n obligatorio**: `DispatchQueue.global` â†’ operaciÃ³n pesada â†’ `DispatchQueue.main.async`

### ğŸ“± SWIFTUI - REACTIVIDAD AUTOMÃTICA (iOS 18.5+)
- âœ… Usar `@Published` - SwiftUI se redibuja automÃ¡ticamente
- âŒ NO usar Timers para delays artificiales
- âŒ NO usar `Task.sleep` para esperas
- âŒ NO usar callbacks manuales (a menos que sea absolutamente necesario)
- âœ… Usar nueva sintaxis de `onChange` - `{ oldValue, newValue in }`
- âœ… Usar `@Observable` macro moderno (opcional)
- âœ… Usar `NavigationStack` moderno

### ğŸ†• NUEVAS REGLAS MVVM APRENDIDAS HOY - OBLIGATORIAS

#### ğŸ”„ GESTIÃ“N DEL CICLO DE VIDA DEL VIEWMODEL
- **ViewModel Protocol**: âœ… Debe conformar `ObservableObject`
- **@StateObject en Views**: âœ… Usar `@StateObject` cuando la vista crea y posee el ViewModel
- **Beneficio**: Evita reinicializaciÃ³n del ViewModel en cada redibujo, previene pÃ©rdida de estado
- **Ejemplo**: `@StateObject private var viewModel = UserListViewModel()`

#### ğŸ’‰ INYECCIÃ“N DE DEPENDENCIAS EN VIEWMODEL
- **Service Injection**: âœ… ViewModel debe recibir service como parÃ¡metro de inicializaciÃ³n
- **Principio**: Dependency Injection para aislar lÃ³gica de persistencia/red
- **Beneficio**: Facilita mocking en tests unitarios y separaciÃ³n de responsabilidades
- **Ejemplo**:
```swift
init(service: UserServiceProtocol) {
    self.service = service
}
```

#### ğŸ“ ESTRUCTURA DEL PROYECTO - ORGANIZACIÃ“N PARA ESCALABILIDAD
- **Directorio Base**: âœ… Mantener para componentes reusables (ej. Loading)
- **Ruta sugerida**: `Base/View/Loading/Loading.swift`
- **OrganizaciÃ³n**: Separar claramente Views, ViewModels, Services, Models
- **Services Organization**: 
  - `Services/Protocols/` - Todos los protocolos de servicios
  - `Services/Implementation/` - Implementaciones concretas de servicios
  - `Services/CoreDataService.swift` - Clase base para servicios Core Data
- **ViewModels Organization**: 
  - `ViewModel/User/` - ViewModels relacionados con usuarios
  - `ViewModel/Group/` - ViewModels relacionados con grupos
  - `ViewModel/Entry/` - ViewModels relacionados con entradas
  - `ViewModel/Item/` - ViewModels relacionados con items
  - `ViewModel/Category/` - ViewModels relacionados con categorÃ­as
- **Views Organization**: 
  - `View/User/` - Vistas relacionadas con usuarios
  - `View/Group/` - Vistas relacionadas con grupos
  - `View/Entry/` - Vistas relacionadas con entradas
  - `View/Base/` - Componentes reusables (Loading, etc.)

#### âš¡ CONCURRENCIA Y ASINCRONÃA
- **Swift Concurrency**: âœ… Usar `async/await` en lugar de callbacks anidados o Combine
- **Beneficios**:
  - CÃ³digo mÃ¡s limpio y legible
  - Manejo integrado de errores con `try/catch`
  - Evita errores de concurrencia al actualizar UI
- **@MainActor**: âœ… Usar cuando sea necesario para operaciones de UI

#### ğŸ¯ RESUMEN DE ROLES
- **ViewModel**: `ObservableObject` que expone datos y lÃ³gica a la vista
- **Service**: Encapsula acceso a datos (API, Core Data, etc.) y se inyecta en ViewModel
- **View**: Usa `@StateObject` para instanciar ViewModel y reaccionar a cambios

#### ğŸš€ OPTIMIZACIONES DE FLUIDEZ - DIFERENCIADORAS
- **@MainActor**: âœ… Usar correctamente en propiedades que actualizan UI
- **Lazy Loading**: âœ… Usar `LazyVStack`, `List` para vistas grandes
- **Procesamiento Pesado**: âŒ NO en cuerpo de vista, âœ… TODO en ViewModel o Services
- **Caching**: âœ… Cachear datos cuando tenga sentido (imÃ¡genes, resultados Core Data)
- **Animaciones**: âœ… Usar `withAnimation` y transiciones nativas SwiftUI

### ğŸš« PROHIBIDO
- Operaciones pesadas en main thread
- LÃ³gica de negocio en Views
- UI elements en ViewModels
- Delays artificiales o polling
- ViewModels sin Dependency Injection
- Views sin @StateObject para ViewModels propios
- ViewModels sin protocolo ObservableObject
- Falta de lazy loading en listas grandes
- Falta de caching para datos frecuentes
- Falta de animaciones suaves

## Project Overview
Building a native iOS personal expense tracker app using SwiftUI (iOS 18.5+) with strict MVVM architecture, Core Data persistence, and NavigationStack navigation building into the view model for simplicity.

## Development Strategy
- **Incremental Development**: Small, focused commits for each feature
- **MVVM First**: All business logic in ViewModels, Views only display
- **Core Data Foundation**: Start with data model, build UI on top
- **Test-Driven**: Unit tests for each component
- **Physical Device Testing**: Always test on physical device, not simulator
- **Device ID**: ALWAYS use "Dennis's iPhone (18.6) (00008120-000A190218614032)" for all testing and build
- **Dependency Injection**: Services injected into ViewModels for testability
- **Lifecycle Management**: Proper @StateObject usage for ViewModel persistence

### Performance Considerations
- Use background queues for Core Data operations
- Implement proper error handling
- Optimize for smooth UI updates
- Follow Apple's native UI/UX conventions
- Use lazy loading for large lists and views
- Cache frequently accessed data
- Implement smooth animations and transitions

Para empezar 

Genera el modelo de datos de Core Data en Swift usando NSManagedObject para cada entidad descrita a continuaciÃ³n, junto con su correspondiente ViewModel siguiendo la arquitectura MVVM.

## ğŸ†• REQUISITOS DE ARQUITECTURA ACTUALIZADOS

### ğŸ“ Estructura del Proyecto
- **Model/**: Entidades Core Data
- **ViewModel/**: ViewModels con inyecciÃ³n de dependencias
- **Service/**: Capa de servicios para operaciones CRUD
- **View/**: Vistas SwiftUI
- **Base/**: Componentes reusables (Loading, etc.)

### ğŸ—ï¸ Modelo (Model/)
- **IMPORTANTE**: Las entidades estÃ¡n configuradas con "Codegen: Class Definition" en Xcode
- **NO crear archivos manuales**: Xcode genera automÃ¡ticamente las clases Core Data en tiempo de compilaciÃ³n
- **Verificar configuraciÃ³n**: Cada entidad en .xcdatamodel debe tener "Codegen: Class Definition"
- **Entidades generadas automÃ¡ticamente**: User, Group, Entry, Item, Category, UserGroup
- **Tipos correctos**: UUID?, Date?, NSDecimalNumber?, Int32, String?, Set<Entity>?
- **Relaciones**: Ya configuradas en .xcdatamodel con delete rules apropiadas

### ğŸ’‰ Vista Modelo (ViewModel/) - ACTUALIZADO
- **Crear un ViewModel por entidad que sea ObservableObject**
- **Incluir un @Published array de la entidad ([Entity]) para la lista de resultados**
- **Incluir un inicializador que reciba Service como parÃ¡metro (Dependency Injection)**
- **Implementar mÃ©todos CRUD (create, fetch, update, delete) para interactuar con Core Data**
- **Gestionar errores y usar try? context.save() de forma segura**
- **ViewModels deben exponer datos ya formateados para uso en SwiftUI (por ejemplo, fecha como String)**
- **Usar @MainActor para operaciones de UI**
- **Implementar lazy loading para listas grandes**
- **Implementar caching para datos frecuentemente accedidos**

### ğŸ”§ Service Layer - NUEVO
- **Crear un Service por entidad que maneje operaciones CRUD**
- **Services deben ser inyectados en ViewModels**
- **Implementar protocols para cada Service (ej: UserServiceProtocol)**
- **Usar background queues para operaciones Core Data**
- **Retornar resultados al main thread para actualizaciones de UI**

### ğŸ‘ï¸ Vista (View/)
- **No es necesario generar vistas completas, pero los ViewModels deben estar listos para enlazarse con SwiftUI**
- **Usar @StateObject para ViewModels que la vista posee**
- **Implementar lazy loading con LazyVStack y List**
- **Usar withAnimation para transiciones suaves**

## Estilo de cÃ³digo
- Swift 5, Xcode 16+ compatible
- Nombrado limpio y consistente con Swift
- Evitar force unwrap (!)
- Incluir comentarios claros para cada relaciÃ³n explicando el deleteRule
- Separar carpetas Model/, ViewModel/, Service/, View/, y Base/
- **Usar async/await para operaciones asÃ­ncronas**
- **Implementar proper error handling con try/catch**
- **Usar @MainActor para operaciones de UI**

## Entidades y atributos:
Category
- id: UUID,
- name: String, default ""
- color: String?, optional, default "#8E8E93"
- createdAt: Date?, optional
- lastModifiedAt: Date?, optional
- Relaciones:
  - entries: Set<Entry>?, to-many, inverse category, delete rule Nullify
  - group: Group?, to-one, inverse categories, delete rule Cascade

Entry
- id: UUID,
- description: String?, optional, default ""
- date: Date,
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- categoryId: UUID,
- groupId: UUID,
- Relaciones:
  - category: Category?, to-one, inverse entries, delete rule Nullify
  - group: Group?, to-one, inverse entries, delete rule Nullify
  - items: Set<Item>?, to-many, inverse entry, delete rule Cascade

Group
- id: UUID,
- name: String?, optional, default ""
- currency: String?, optional, default "USD"
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - entries: Set<Entry>?, to-many, inverse group, delete rule Cascade
  - categories: Set<Category>?, to-many, inverse group, delete rule Cascade
  - userGroups: Set<UserGroup>?, to-many, inverse group, delete rule Cascade

Item
- id: UUID,
- description: String?, optional, default ""
- amount: NSDecimalNumber?, optional, default 0.0
- quantity: Int32, optional, default 1
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - entry: Entry?, to-one, inverse items, delete rule Nullify

User
- id: UUID?, optional
- name: String?, optional, default ""
- email: String,
- createdAt: Date?, optional auto generated
- lastModifiedAt: Date?, optional auto generated
- Relaciones:
  - userGroups: Set<UserGroup>?, to-many, inverse user, delete rule Cascade

UserGroup
- id: UUID,
- role: String?, optional, default "owner"
- joinedAt: Date?, optional auto generated
- userId: UUID,
- groupId: UUID,
- Relaciones:
  - user: User?, to-one, inverse userGroups, delete rule Cascade
  - group: Group?, to-one, inverse userGroups, delete rule Cascade

## ğŸ†• Requisitos adicionales actualizados:
- **IMPORTANTE**: Las entidades Core Data estÃ¡n configuradas con "Codegen: Class Definition" en Xcode
- **NO crear archivos manuales**: Xcode genera automÃ¡ticamente las clases Core Data en tiempo de compilaciÃ³n
- **Implementa Service layer con protocols para cada entidad**
- **ViewModels deben recibir Services como parÃ¡metros de inicializaciÃ³n**
- **Usa @StateObject en Views para ViewModels propios**
- **Implementa lazy loading y caching para performance**
- **Usa async/await para operaciones asÃ­ncronas**
- **Implementa proper error handling con try/catch**
- **Usa @MainActor para operaciones de UI**
- **Implementa animaciones suaves con withAnimation**

## ğŸ—ï¸ **ESTRUCTURA DE DIRECTORIOS OBLIGATORIA PARA ESCALABILIDAD**

### **Services/**
```
Services/
â”œâ”€â”€ Protocols/              # Protocolos de servicios para DI
â”‚   â”œâ”€â”€ UserServiceProtocol.swift
â”‚   â”œâ”€â”€ GroupServiceProtocol.swift
â”‚   â”œâ”€â”€ EntryServiceProtocol.swift
â”‚   â”œâ”€â”€ ItemServiceProtocol.swift
â”‚   â”œâ”€â”€ CategoryServiceProtocol.swift
â”‚   â””â”€â”€ UserGroupServiceProtocol.swift
â”œâ”€â”€ Implementation/         # Implementaciones concretas
â”‚   â”œâ”€â”€ UserService.swift
â”‚   â”œâ”€â”€ GroupService.swift
â”‚   â”œâ”€â”€ EntryService.swift
â”‚   â”œâ”€â”€ ItemService.swift
â”‚   â”œâ”€â”€ CategoryService.swift
â”‚   â””â”€â”€ UserGroupService.swift
â””â”€â”€ CoreDataService.swift   # Clase base para servicios
```

### **ViewModels/**
```
ViewModel/
â”œâ”€â”€ User/                   # ViewModels relacionados con usuarios
â”œâ”€â”€ Group/                  # ViewModels relacionados con grupos
â”œâ”€â”€ Entry/                  # ViewModels relacionados con entradas
â”œâ”€â”€ Item/                   # ViewModels relacionados con items
â””â”€â”€ Category/               # ViewModels relacionados con categorÃ­as
```

### **Views/**
```
View/
â”œâ”€â”€ User/                   # Vistas relacionadas con usuarios
â”œâ”€â”€ Group/                  # Vistas relacionadas con grupos
â”œâ”€â”€ Entry/                  # Vistas relacionadas con entradas
â””â”€â”€ Base/                   # Componentes reusables (Loading, etc.)
```

### **Imports en Swift - IMPORTANTE**
- **NO usar @_exported import**: En Swift, cuando todos los archivos estÃ¡n en el mismo target, son automÃ¡ticamente visibles
- **Imports automÃ¡ticos**: Los protocolos y clases se importan automÃ¡ticamente dentro del mismo mÃ³dulo
- **Mantener imports bÃ¡sicos**: Solo `import Foundation` e `import CoreData` son necesarios
- **Simplicidad**: No necesitamos archivos de imports centralizados en Swift
- **Uso de protocolos**: Usar `any ProtocolName` para evitar warnings de Swift

## ğŸš¨ RECORDATORIOS CRÃTICOS - REVISAR ANTES DE CADA IMPLEMENTACIÃ“N

### âœ… VERIFICAR ANTES DE IMPLEMENTAR:
1. **Views**: Â¿Solo contienen SwiftUI Views sin lÃ³gica?
2. **ViewModels**: Â¿Solo contienen lÃ³gica de negocio sin UI?
3. **Threading**: Â¿Operaciones pesadas en background, UI en main?
4. **@Published**: Â¿Se usa para reactividad automÃ¡tica?
5. **@MainActor**: Â¿Se usa en ViewModels para operaciones de UI?
6. **Delays**: Â¿NO hay Timers o delays artificiales?
7. **iOS 18.5+**: Â¿Se usan APIs modernas, no deprecadas?
8. **onChange**: Â¿Se usa nueva sintaxis `{ oldValue, newValue in }`?
9. **@StateObject**: Â¿Se usa para ViewModels que la vista posee?
10. **Dependency Injection**: Â¿Los ViewModels reciben services como parÃ¡metros?
11. **ObservableObject**: Â¿Todos los ViewModels conforman el protocolo?
12. **Lazy Loading**: Â¿Se usa para listas y vistas grandes?
13. **Caching**: Â¿Se implementa para datos frecuentemente accedidos?
14. **Animations**: Â¿Se usan withAnimation y transiciones nativas?

### ğŸ¯ OBJETIVO FINAL
**UI completamente fluida, sin bloqueos, con operaciones pesadas ejecutÃ¡ndose en background y actualizaciones automÃ¡ticas en main thread usando la reactividad automÃ¡tica de SwiftUI, implementando las mejores prÃ¡cticas MVVM aprendidas hoy.**

---

**RECUERDA: Cada lÃ­nea de cÃ³digo debe seguir estas reglas estrictas. La arquitectura MVVM, el threading correcto, la inyecciÃ³n de dependencias, y la gestiÃ³n del ciclo de vida del ViewModel son OBLIGATORIOS para mantener la fluidez de la UI y la mantenibilidad del cÃ³digo.**
