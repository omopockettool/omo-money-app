# OMOMoney - Reglas Estrictas de Desarrollo

## ğŸ“± VERSIÃ“N DE PLATAFORMA
- **iOS Target**: iOS 18.5+ (2025)
- **Xcode**: Ãšltima versiÃ³n estable
- **SwiftUI**: Usar APIs mÃ¡s modernas disponibles
- **Compatibilidad**: iOS 18.5+ (puede usar todas las APIs modernas)

## ğŸ—ï¸ ARQUITECTURA MVVM - OBLIGATORIA

### **Views (Solo UI):**
- âœ… **Solo contienen SwiftUI Views**
- âœ… **NO contienen lÃ³gica de negocio**
- âœ… **NO contienen funciones de cÃ¡lculo**
- âœ… **NO contienen formateo de datos**
- âœ… **Usan @StateObject para ViewModels**
- âœ… **Usan @ObservedObject para ViewModels compartidos**

### **ViewModels (Solo LÃ³gica de Negocio):**
- âœ… **Solo contienen lÃ³gica de negocio**
- âœ… **NO contienen UI**
- âœ… **Usan @MainActor para operaciones de UI**
- âœ… **Usan @Published para propiedades observables**
- âœ… **Manejan estado de la aplicaciÃ³n**

### **Models (Solo Datos):**
- âœ… **Solo contienen entidades de Core Data**
- âœ… **NO contienen lÃ³gica**
- âœ… **NO contienen UI**

## ğŸ§µ THREADING - REGLAS ESTRICTAS

### **Main Thread (Solo UI):**
- âœ… **NavegaciÃ³n** - `navigationPath.append()`, `navigationPath.removeLast()`
- âœ… **ActualizaciÃ³n de UI** - Cambios en `@Published` properties
- âœ… **Gestos y eventos** - Button actions, tap gestures
- âœ… **Animaciones** - Transiciones, animaciones de SwiftUI

### **Background Thread (Operaciones Pesadas):**
- âœ… **Core Data CRUD** - `context.perform { }`
- âœ… **CÃ¡lculos complejos** - Sumas, filtros, ordenamiento
- âœ… **Operaciones de red** - API calls, descargas
- âœ… **Procesamiento de archivos** - Lectura/escritura
- âœ… **Operaciones de base de datos** - Queries complejas

### **ğŸš¨ REGLAS CRÃTICAS DE CORE DATA - NUNCA OLVIDAR:**

#### **1. Core Data en Segundo Plano:**
- âœ… **SIEMPRE usar** `context.perform { ... }` o `context.performAndWait { ... }`
- âœ… **NUNCA tocar** `NSManagedObject` desde otro hilo que no sea el de su contexto
- âœ… **Evitar race conditions** y corrupciÃ³n de datos
- âœ… **Asegurar acceso seguro** a objetos gestionados en la queue correcta

#### **2. @Published y Hilos:**
- âŒ **NUNCA modificar** propiedades `@Published` desde background threads
- âŒ **NUNCA acceder** a `ObservableObject` desde background threads
- âœ… **SIEMPRE volver** al main thread antes de actualizar `@Published`
- âœ… **SwiftUI y Combine** NO son thread-safe para actualizaciones de UI

#### **3. PatrÃ³n Seguro Obligatorio:**
```swift
// âœ… CORRECTO - Core Data seguro + UI thread-safe
func fetchData() {
    isLoading = true
    
    context.perform {
        // âœ… Core Data en su hilo seguro
        let request: NSFetchRequest<Entity> = Entity.fetchRequest()
        let resultados = try? self.context.fetch(request)
        
        // âœ… Volver al main thread para @Published
        DispatchQueue.main.async {
            self.items = resultados ?? []
            self.isLoading = false
        }
    }
}

// âŒ INCORRECTO - ViolaciÃ³n de reglas
func fetchDataWrong() {
    DispatchQueue.global(qos: .userInitiated).async {
        // âŒ Acceso directo a @Published desde background
        let data = self.items.filter { ... }
        
        DispatchQueue.main.async {
            completion(data)
        }
    }
}
```

### **PatrÃ³n Obligatorio:**
```swift
// âŒ INCORRECTO - OperaciÃ³n pesada en main thread
func heavyOperation() {
    let result = complexCalculation() // Bloquea UI
    self.result = result
}

// âœ… CORRECTO - OperaciÃ³n pesada en background
func heavyOperation() {
    DispatchQueue.global(qos: .userInitiated).async {
        let result = self.complexCalculation() // En background
        
        DispatchQueue.main.async {
            self.result = result // UI update en main thread
        }
    }
}
```

## ğŸ“± SWIFTUI - REGLAS ESTRICTAS (iOS 18.5+)

### **Reactividad AutomÃ¡tica:**
- âœ… **Usar @Published** - SwiftUI se redibuja automÃ¡ticamente
- âœ… **NO usar callbacks manuales** - A menos que sea absolutamente necesario
- âœ… **NO usar Timers** - Para polling o delays artificiales
- âœ… **NO usar Task.sleep** - Para esperas artificiales

### **iOS 18.5 - APIs Modernas:**
- âœ… **onChange** - Usar nueva sintaxis de dos parÃ¡metros
- âœ… **NavigationStack** - NavegaciÃ³n moderna
- âœ… **@Observable** - Macro moderno para observabilidad
- âœ… **ScrollView** - Nuevas capacidades de scroll
- âœ… **Charts** - Framework nativo de grÃ¡ficos
- âœ… **Data** - Nuevas capacidades de manejo de datos
- âœ… **Widgets** - Widgets interactivos modernos

### **PatrÃ³n de Estado:**
```swift
@MainActor
class MyViewModel: ObservableObject {
    @Published var isLoading = false
    @Published var data: [Item] = []
    @Published var errorMessage: String?
    
    func loadData() {
        isLoading = true
        
        DispatchQueue.global(qos: .userInitiated).async {
            let result = self.fetchDataFromDatabase()
            
            DispatchQueue.main.async {
                self.data = result
                self.isLoading = false
            }
        }
    }
}
```

## ğŸš« PROHIBIDO

### **En Views:**
- âŒ Funciones de cÃ¡lculo
- âŒ Formateo de datos
- âŒ LÃ³gica de negocio
- âŒ Operaciones de Core Data
- âŒ Timers o delays artificiales

### **En Main Thread:**
- âŒ Operaciones CRUD de Core Data
- âŒ CÃ¡lculos complejos
- âŒ Filtros de arrays grandes
- âŒ Operaciones de red
- âŒ Procesamiento de archivos

### **En ViewModels:**
- âŒ UI elements
- âŒ SwiftUI Views
- âŒ NavegaciÃ³n directa
- âŒ Gestos o eventos

### **ğŸš¨ PROHIBICIONES ABSOLUTAS DE THREADING:**

#### **Core Data:**
- âŒ **NUNCA** usar `DispatchQueue.global` para operaciones de Core Data
- âŒ **NUNCA** acceder a `NSManagedObject` desde fuera de su contexto
- âŒ **NUNCA** llamar a mÃ©todos de ViewModel desde background threads
- âŒ **NUNCA** usar `DispatchQueue.global` para filtrar propiedades `@Published`

#### **@Published y ObservableObject:**
- âŒ **NUNCA** modificar `@Published` desde background threads
- âŒ **NUNCA** acceder a propiedades `@Published` desde `DispatchQueue.global`
- âŒ **NUNCA** llamar a mÃ©todos `@MainActor` desde background threads
- âŒ **NUNCA** usar `DispatchQueue.global` para operaciones que requieran datos del main thread

#### **Patrones Incorrectos Eliminados:**
```swift
// âŒ PROHIBIDO - Eliminar completamente
func fetchDataAsync(completion: @escaping ([Entity]) -> Void) {
    DispatchQueue.global(qos: .userInitiated).async {
        // âŒ Acceso a @Published desde background
        let data = self.items.filter { ... }
        
        DispatchQueue.main.async {
            completion(data)
        }
    }
}

// âŒ PROHIBIDO - Eliminar completamente
func calculateAsync(completion: @escaping (Result) -> Void) {
    DispatchQueue.global(qos: .userInitiated).async {
        // âŒ Llamada a mÃ©todo @MainActor desde background
        let result = self.heavyCalculation()
        
        DispatchQueue.main.async {
            completion(result)
        }
    }
}
```

## ğŸ”„ FLUJO CORRECTO

1. **Usuario interactÃºa** â†’ View (Main Thread)
2. **View llama ViewModel** â†’ ViewModel (Main Thread)
3. **ViewModel ejecuta operaciÃ³n pesada** â†’ Background Thread
4. **ViewModel actualiza @Published** â†’ Main Thread
5. **SwiftUI se redibuja automÃ¡ticamente** â†’ View (Main Thread)

## ğŸ“ EJEMPLOS DE IMPLEMENTACIÃ“N (iOS 18.5+)

### **onChange Moderno:**
```swift
// âŒ DEPRECATED en iOS 18.5 - No usar
.onChange(of: someValue) { newValue in
    // action
}

// âœ… CORRECTO en iOS 18.5 - Usar nueva sintaxis
.onChange(of: someValue) { oldValue, newValue in
    // action with both old and new values
}

// âœ… TambiÃ©n vÃ¡lido - Solo newValue
.onChange(of: someValue) { newValue in
    // action with only new value
}
```

### **Crear Entidad:**
```swift
// ViewModel
func createItem(name: String) {
    isLoading = true
    
    DispatchQueue.global(qos: .userInitiated).async {
        let success = self.context.perform {
            // Core Data operation in background
            let item = Item(context: self.context)
            item.name = name
            try self.context.save()
        }
        
        DispatchQueue.main.async {
            self.isLoading = false
            if success {
                self.fetchItems() // Trigger UI update
            }
        }
    }
}
```

### **CÃ¡lculo Pesado:**
```swift
// ViewModel
func calculateTotal() {
    isCalculating = true
    
    DispatchQueue.global(qos: .userInitiated).async {
        let total = self.items.reduce(0) { sum, item in
            sum + (item.amount ?? 0)
        }
        
        DispatchQueue.main.async {
            self.total = total
            self.isCalculating = false
        }
    }
}
```

## ğŸ¯ OBJETIVO FINAL

**UI completamente fluida, sin bloqueos, con operaciones pesadas ejecutÃ¡ndose en background y actualizaciones automÃ¡ticas en main thread.**

## ğŸ” VERIFICACIÃ“N OBLIGATORIA ANTES DE CADA COMMIT

### **âœ… CHECKLIST DE THREADING:**
1. **Core Data**: Â¿Se usa SOLO `context.perform` para operaciones de background?
2. **@Published**: Â¿Se actualiza SOLO desde el main thread?
3. **DispatchQueue.global**: Â¿NO se usa para acceder a propiedades del ViewModel?
4. **@MainActor**: Â¿NO se viola desde background threads?
5. **Race Conditions**: Â¿Se evita el acceso concurrente a Core Data?

### **âœ… CHECKLIST DE ARQUITECTURA:**
1. **Views**: Â¿Solo contienen SwiftUI Views sin lÃ³gica?
2. **ViewModels**: Â¿Solo contienen lÃ³gica de negocio sin UI?
3. **Models**: Â¿Solo contienen entidades Core Data sin lÃ³gica?
4. **Threading**: Â¿Operaciones pesadas en background, UI en main?

### **âŒ VERIFICAR QUE NO EXISTA:**
- MÃ©todos que usen `DispatchQueue.global` para acceder a `@Published`
- Llamadas a mÃ©todos `@MainActor` desde background threads
- Acceso directo a `NSManagedObject` desde fuera de su contexto
- Filtros de propiedades `@Published` desde `DispatchQueue.global`

---

**ğŸš¨ RECUERDA: Cada vez que escribas cÃ³digo, verifica que siga estas reglas estrictas. La arquitectura MVVM y el threading correcto son OBLIGATORIOS.**
